"""
Count unique degree sequences of subforests in a bipartite graph.

This script processes all subgraphs of a bipartite graph, identifies which ones
are forests, extracts their degree sequences, and tracks the number of unique
degree sequences found.
"""


# This file was *autogenerated* from the file count_unique_degree_sequences_bipartite.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3)
load("helpers.sage")


def get_degree_sequence(graph):
    """
    Get the sorted degree sequence of a graph.
    
    Args:
        graph: A Sage Graph object
    
    Returns:
        A tuple representing the sorted degree sequence
    """
    degrees = sorted(graph.degree())
    return tuple(degrees)


def count_subforests_with_unique_degree_sequences_bipartite(graph):
    """
    Count subforests in a bipartite graph and track unique degree sequences.
    
    Args:
        graph: A Sage Graph object (must be bipartite)
    
    Returns:
        Tuple of (count_forests, unique_degree_sequences_set)
    
    Raises:
        ValueError: If the graph is not bipartite
    """
    if not graph.is_bipartite():
        raise ValueError("The input graph must be bipartite!")
    
    vertices = list(graph.vertices())
    edges = list(graph.edges(labels=False))
    n_edges = len(edges)
    
    count_forests = _sage_const_0 
    unique_degree_sequences = set()
    
    # Iterate through all possible subsets of edges
    for edge_subset_bits in range(_sage_const_2 **n_edges):
        # Create a subgraph from this subset of edges
        selected_edges = []
        for i in range(n_edges):
            if edge_subset_bits & (_sage_const_1  << i):
                selected_edges.append(edges[i])
        
        # Create subgraph with the selected edges
        subgraph = graph.subgraph(vertices=vertices, edges=selected_edges)
        
        # Check if it's a forest
        if is_forest(subgraph):
            count_forests += _sage_const_1 
            
            # Extract degree sequence and add to set
            degree_seq = get_degree_sequence(subgraph)
            unique_degree_sequences.add(degree_seq)
    
    return count_forests, unique_degree_sequences


if __name__ == "__main__":
    # Example: Create small bipartite graphs and analyze degree sequences
    
    # Example 1: Complete bipartite graph K_{2,2}
    print("Example 1: Complete bipartite graph K_{2,2}")
    G1 = graphs.CompleteBipartiteGraph(_sage_const_2 , _sage_const_2 )
    print(f"Vertices: {G1.vertices()}")
    print(f"Edges: {G1.edges(labels=False)}")
    print(f"Is bipartite: {G1.is_bipartite()}")
    print(f"Number of edges: {G1.num_edges()}")
    
    count1, unique_seqs1 = count_subforests_with_unique_degree_sequences_bipartite(G1)
    print(f"Number of subforests: {count1}")
    print(f"Number of unique degree sequences: {len(unique_seqs1)}")
    print(f"Unique degree sequences: {sorted(unique_seqs1)}\n")
    
    # Example 2: Path graph (which is bipartite)
    print("Example 2: Path graph with 4 vertices")
    G2 = graphs.PathGraph(_sage_const_4 )
    print(f"Vertices: {G2.vertices()}")
    print(f"Edges: {G2.edges(labels=False)}")
    print(f"Is bipartite: {G2.is_bipartite()}")
    print(f"Number of edges: {G2.num_edges()}")
    
    count2, unique_seqs2 = count_subforests_with_unique_degree_sequences_bipartite(G2)
    print(f"Number of subforests: {count2}")
    print(f"Number of unique degree sequences: {len(unique_seqs2)}")
    print(f"Unique degree sequences: {sorted(unique_seqs2)}\n")
    
    # Example 3: Cycle graph with 4 vertices (bipartite)
    print("Example 3: Cycle with 4 vertices")
    G3 = graphs.CycleGraph(_sage_const_4 )
    print(f"Vertices: {G3.vertices()}")
    print(f"Edges: {G3.edges(labels=False)}")
    print(f"Is bipartite: {G3.is_bipartite()}")
    print(f"Number of edges: {G3.num_edges()}")
    
    count3, unique_seqs3 = count_subforests_with_unique_degree_sequences_bipartite(G3)
    print(f"Number of subforests: {count3}")
    print(f"Number of unique degree sequences: {len(unique_seqs3)}")
    print(f"Unique degree sequences: {sorted(unique_seqs3)}\n")
    
    # Example 4: Complete bipartite graph K_{3,3}
    print("Example 4: Complete bipartite graph K_{3,3}")
    G4 = graphs.CompleteBipartiteGraph(_sage_const_3 , _sage_const_3 )
    print(f"Is bipartite: {G4.is_bipartite()}")
    print(f"Number of vertices: {G4.num_verts()}")
    print(f"Number of edges: {G4.num_edges()}")
    
    count4, unique_seqs4 = count_subforests_with_unique_degree_sequences_bipartite(G4)
    print(f"Number of subforests: {count4}")
    print(f"Number of unique degree sequences: {len(unique_seqs4)}")
    print(f"Unique degree sequences: {sorted(unique_seqs4)}\n")
    
    # Example 5: Non-bipartite graph (triangle) - should raise error
    print("Example 5: Triangle (non-bipartite) - should raise error")
    G5 = graphs.CycleGraph(_sage_const_3 )
    print(f"Is bipartite: {G5.is_bipartite()}")
    
    try:
        count5, unique_seqs5 = count_subforests_with_unique_degree_sequences_bipartite(G5)
    except ValueError as e:
        print(f"Error caught: {e}\n")

