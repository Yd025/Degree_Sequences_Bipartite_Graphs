Meeting minutes office hours 2/25/2026

Progress so far:
- we are able to take in a graph, write a loop into every possible combination of edge (2^n) and then check if the subgraph is a subforest
- runtime is extremely slow because its O(2^n) * O(1)

What we want to do is to check for every cycle if there are any subforests 
- Might not be that much of a speedup 
- Count the number of sets that include one cycle, and more cycle, and do inclusion exclusion theorem

To-do:
DQ: Write the count unique degree sequences within count_subforests.sage
Yd: Optimize the count number of subforests and do it recursively 

Renaming convention 
- (do what)_(to what).sage for all function .sage files 
    - e.g. count_subforests_bipartite.sage contains only the function to count unique subforests in a biparte graph
- test_(do what)_(to what).sage for all files that are used for testing, with in built test cases